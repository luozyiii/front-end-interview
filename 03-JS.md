# JS 基础

## 变量类型和计算

### 题目

- typeof 能判断哪些类型？

- 何时使用 === 何时使用 ==？

- 值类型和引用类型的区别？

- 手写深拷贝？

### 知识点

####  变量类型

##### 值类型 vs 引用类型(堆栈模型)
```javascript
// 值类型：在栈中存储
let a = 100
let b = a
a = 200
console.log(b) // 100

// 引用类型：在栈中存储的是堆的内存地址
let c = { age: 20 }
let d = c
d.age = 21
console.log(c.age) // 21

// 常见的值类型
let a // undefined
const s = 'abc'
const n = 100
const b = true
const z = Symbol('z')

// 常见引用类型
const obj = { x: 100 }
const arr = ['a', 'b', 'c']
const n = null // null：特殊引用类型，指针指向了空地址
// 函数：特殊引用类型，但不用于存储数据，所有没有“拷贝、复制函数”这一说
function fn() {}
```

##### typeof运算符
- 识别所有值类型
```javascript
let a;                   typeof a   // 'undefined'
const str = 'abc';       typeof str // 'string'
const n = 100;           typeof n   // 'number'
const b = true;          typeof b   // 'boolean'
const z = Symbol('z');   typeof z   // 'symbol'
```

- 识别函数
```javascript
typeof console.log       // 'function'
typeof function() {}     // 'function'
```

- 判断是否是引用类型(不可再细分)
```javascript
typeof null              // 'object'
typeof ['b','b']         // 'object'
typeof { x: 10 }         // 'object'

```

##### 深拷贝
> js-demo
- 注意判断值类型和引用类型
- 注意判断是数组还是对象
- 递归

#### 变量计算-类型转换
```javascript
// 字符串拼接
const a = 100 + 10    // 110
const b = 100 + '10'  // '11010'
const c = true + '10' // 'true10'

// == 运算符
100 == '100'  // true
0 == ''       // true
0 == false    // true
fales == ''   // true
null == undefined // true

// 除了 == null 之外，其他都一律使用 === ，例如：
const obj = {x: 100}
if(obj.a == null) {}
// 相当于
// if(obj.a === null || obj.a === undefined) {}
```

- if语句和逻辑判断
```javascript
// truly变量： !!a === true 的变量
// falsely变量：!!a === false 的变量

// 以下是 falsely 变量。除此之外都是 truly 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false

// 逻辑判断
console.log(10 && 0) // 0
console.log('' || 'abc') // 'abc'
console.log(!window.abc) // true
```

## 原型和原型链

### 题目

- 如何准确判断一个变量是不是数组？
a instanceof Array

- 手写一个简易的JQuery，考虑插件和拓展性
> jquery-demo.js

- class的原型本质，怎么理解？
原型和原型链的图示；属性和方法的执行规则

### 知识点

#### class 和继承

##### class
- constructor
- 属性
- 方法

```javascript
class Student {
    constructor(name, number) {
        this.name = name
        this.number = number
    }
    sayHi() {
        console.log(`姓名：${this.name}，学号：${this.number}`)
    }
}

// 通过类声明对象/实例
const xialuo = new Student('夏洛',100)
console.log(xialuo.name)
console.log(xialuo.number)
console.log(xialuo.sayHi())
```

##### 继承
- extends
- super
```javascript
// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}

class Student extends People {
    constructor(name, number){
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名：${this.name}，学号：${this.number}`)
    }
}

class Teacher extends People {
    constructor(name, major){
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}
```

#### 类型判断instanceof
```javascript
xialuo instanceof Student  // true
xialuo instanceof People   // true
xialuo instanceof Object   // true

[] instanceof Array        // true
[] instanceof Object       // true

{} instanceof Object       // true
```

#### 原型和原型链
##### 原型
```javascript
// class 实际上是函数，可见是语法糖
typeof People  // 'function'
typeof Student // 'function'

// 隐式原型和显示原型
console.log(xialuo.__proto__) // 隐式原型
console.log(Student.prototype) // 显示原型
console.log(xialuo.__proto__ === Student.prototype) // true
```
- 每个class都有显示原型 prototype
- 每个实例都有隐式原型 __proto__
- 实例的 __proto__ 指向对应 class 的prototype

##### 基于原型的执行规则
- 获取属性xialuo.nane 或执行方法xialuo.sayHi()时
- 先在自身属性和方法寻找
- 如果找不到则自动去 __proto__ 中查找

##### 原型链
```javascript
console.log(Student.prototype.__proto__)
console.log(People.prototype)
console.log(Student.prototype.__proto__ === People.prototype) // true

xialuo.hasOwnProperty('name') // true
xialuo.hasOwnProperty('eat')  // false
```
![原型链](./assets/images/yuanxinglian.png)
##### instanceof 是基于原型链实现的